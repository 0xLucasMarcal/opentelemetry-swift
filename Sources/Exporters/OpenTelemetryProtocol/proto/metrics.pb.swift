// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AggregationTemporality defines how a metric aggregator reports aggregated
/// values. It describes how those values relate to the time interval over
/// which they are aggregated.
public enum Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
  case unspecified // = 0

  /// DELTA is an AggregationTemporality for a metric aggregator which reports
  /// changes since last report time. Successive metrics contain aggregation of
  /// values from continuous and non-overlapping intervals.
  ///
  /// The values for a DELTA metric are based only on the time interval
  /// associated with one measurement cycle. There is no dependency on
  /// previous measurements like is the case for CUMULATIVE metrics.
  ///
  /// For example, consider a system measuring the number of requests that
  /// it receives and reports the sum of these requests every second as a
  /// DELTA metric:
  ///
  ///   1. The system starts receiving at time=t_0.
  ///   2. A request is received, the system measures 1 request.
  ///   3. A request is received, the system measures 1 request.
  ///   4. A request is received, the system measures 1 request.
  ///   5. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+1 with a value of 3.
  ///   6. A request is received, the system measures 1 request.
  ///   7. A request is received, the system measures 1 request.
  ///   8. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0+1 to
  ///      t_0+2 with a value of 2.
  case delta // = 1

  /// CUMULATIVE is an AggregationTemporality for a metic aggregator which
  /// reports changes since a fixed start time. This means that current values
  /// of a CUMULATIVE metric depend on all previous measurements since the
  /// start time. Because of this, the sender is required to retain this state
  /// in some form. If this state is lost or invalidated, the CUMULATIVE metric
  /// values MUST be reset and a new fixed start time following the last
  /// reported measurement time sent MUST be used.
  ///
  /// For example, consider a system measuring the number of requests that
  /// it receives and reports the sum of these requests every second as a
  /// CUMULATIVE metric:
  ///
  ///   1. The system starts receiving at time=t_0.
  ///   2. A request is received, the system measures 1 request.
  ///   3. A request is received, the system measures 1 request.
  ///   4. A request is received, the system measures 1 request.
  ///   5. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+1 with a value of 3.
  ///   6. A request is received, the system measures 1 request.
  ///   7. A request is received, the system measures 1 request.
  ///   8. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_0 to
  ///      t_0+2 with a value of 5.
  ///   9. The system experiences a fault and loses state.
  ///   10. The system recovers and resumes receiving at time=t_1.
  ///   11. A request is received, the system measures 1 request.
  ///   12. The 1 second collection cycle ends. A metric is exported for the
  ///      number of requests received over the interval of time t_1 to
  ///      t_0+1 with a value of 1.
  ///
  /// Note: Even though, when reporting changes since last report time, using 
  /// CUMULATIVE is valid, it is not recommended. This may cause problems for
  /// systems that do not use start_time to determine when the aggregation
  /// value was reset (e.g. Prometheus).
  case cumulative // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .delta
    case 2: self = .cumulative
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .delta: return 1
    case .cumulative: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opentelemetry_Proto_Metrics_V1_AggregationTemporality] = [
    .unspecified,
    .delta,
    .cumulative,
  ]
}

#endif  // swift(>=4.2)

/// A collection of InstrumentationLibraryMetrics from a Resource.
public struct Opentelemetry_Proto_Metrics_V1_ResourceMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the metrics in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _storage._resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// A list of metrics that originate from a resource.
  public var instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] {
    get {return _storage._instrumentationLibraryMetrics}
    set {_uniqueStorage()._instrumentationLibraryMetrics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A collection of Metrics produced by an InstrumentationLibrary.
public struct Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation library information for the metrics in this message.
  /// If this field is not set then no library info is known.
  public var instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary {
    get {return _storage._instrumentationLibrary ?? Opentelemetry_Proto_Common_V1_InstrumentationLibrary()}
    set {_uniqueStorage()._instrumentationLibrary = newValue}
  }
  /// Returns true if `instrumentationLibrary` has been explicitly set.
  public var hasInstrumentationLibrary: Bool {return _storage._instrumentationLibrary != nil}
  /// Clears the value of `instrumentationLibrary`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentationLibrary() {_uniqueStorage()._instrumentationLibrary = nil}

  /// A list of metrics that originate from an instrumentation library.
  public var metrics: [Opentelemetry_Proto_Metrics_V1_Metric] {
    get {return _storage._metrics}
    set {_uniqueStorage()._metrics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines a Metric which has one or more timeseries.
///
/// The data model and relation between entities is shown in the
/// diagram below. Here, "DataPoint" is the term used to refer to any
/// one of the specific data point value types, and "points" is the term used
/// to refer to any one of the lists of points contained in the Metric.
///
/// - Metric is composed of a metadata and data.
/// - Metadata part contains a name, description, unit.
/// - Data is one of the possible types (Gauge, Sum, Histogram, etc.).
/// - DataPoint contains timestamps, labels, and one of the possible value type
///   fields.
///
///     Metric
///  +------------+
///  |name        |
///  |description |
///  |unit        |     +---------------------------+
///  |data        |---> |Gauge, Sum, Histogram, ... |
///  +------------+     +---------------------------+ 
///
///    Data [One of Gauge, Sum, Histogram, ...]
///  +-----------+
///  |...        |  // Metadata about the Data.
///  |points     |--+
///  +-----------+  |
///                 |      +---------------------------+
///                 |      |DataPoint 1                |
///                 v      |+------+------+   +------+ |
///              +-----+   ||label |label |...|label | |
///              |  1  |-->||value1|value2|...|valueN| |
///              +-----+   |+------+------+   +------+ |
///              |  .  |   |+-----+                    |
///              |  .  |   ||value|                    |
///              |  .  |   |+-----+                    |
///              |  .  |   +---------------------------+
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |                   .
///              |  .  |   +---------------------------+
///              |  .  |   |DataPoint M                |
///              +-----+   |+------+------+   +------+ |
///              |  M  |-->||label |label |...|label | |
///              +-----+   ||value1|value2|...|valueN| |
///                        |+------+------+   +------+ |
///                        |+-----+                    |
///                        ||value|                    |
///                        |+-----+                    |
///                        +---------------------------+
///
/// All DataPoint types have three common fields:
/// - Labels zero or more key-value pairs associated with the data point.
/// - StartTimeUnixNano MUST be set to the start of the interval when the data's
///   type includes an AggregationTemporality. This field is not set otherwise.
/// - TimeUnixNano MUST be set to:
///   - the moment when an aggregation is reported (independent of the
///     aggregation temporality).
///   - the instantaneous time of the event.
public struct Opentelemetry_Proto_Metrics_V1_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the metric, including its DNS name prefix. It must be unique.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// description of the metric, which can be used in documentation.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// unit in which the metric value is reported. Follows the format
  /// described by http://unitsofmeasure.org/ucum.html.
  public var unit: String {
    get {return _storage._unit}
    set {_uniqueStorage()._unit = newValue}
  }

  /// Data determines the aggregation type (if any) of the metric, what is the
  /// reported value type for the data points, as well as the relatationship to
  /// the time interval over which they are reported.
  ///
  /// TODO: Update table after the decision on:
  /// https://github.com/open-telemetry/opentelemetry-specification/issues/731.
  /// By default, metrics recording using the OpenTelemetry API are exported as
  /// (the table does not include MeasurementValueType to avoid extra rows):
  ///
  ///   Instrument         Type
  ///   ----------------------------------------------
  ///   Counter            Sum(aggregation_temporality=delta;is_monotonic=true)
  ///   UpDownCounter      Sum(aggregation_temporality=delta;is_monotonic=false)
  ///   ValueRecorder      TBD
  ///   SumObserver        Sum(aggregation_temporality=cumulative;is_monotonic=true)
  ///   UpDownSumObserver  Sum(aggregation_temporality=cumulative;is_monotonic=false)
  ///   ValueObserver      Gauge()
  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  public var intGauge: Opentelemetry_Proto_Metrics_V1_IntGauge {
    get {
      if case .intGauge(let v)? = _storage._data {return v}
      return Opentelemetry_Proto_Metrics_V1_IntGauge()
    }
    set {_uniqueStorage()._data = .intGauge(newValue)}
  }

  public var doubleGauge: Opentelemetry_Proto_Metrics_V1_DoubleGauge {
    get {
      if case .doubleGauge(let v)? = _storage._data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleGauge()
    }
    set {_uniqueStorage()._data = .doubleGauge(newValue)}
  }

  public var intSum: Opentelemetry_Proto_Metrics_V1_IntSum {
    get {
      if case .intSum(let v)? = _storage._data {return v}
      return Opentelemetry_Proto_Metrics_V1_IntSum()
    }
    set {_uniqueStorage()._data = .intSum(newValue)}
  }

  public var doubleSum: Opentelemetry_Proto_Metrics_V1_DoubleSum {
    get {
      if case .doubleSum(let v)? = _storage._data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleSum()
    }
    set {_uniqueStorage()._data = .doubleSum(newValue)}
  }

  public var intHistogram: Opentelemetry_Proto_Metrics_V1_IntHistogram {
    get {
      if case .intHistogram(let v)? = _storage._data {return v}
      return Opentelemetry_Proto_Metrics_V1_IntHistogram()
    }
    set {_uniqueStorage()._data = .intHistogram(newValue)}
  }

  public var doubleHistogram: Opentelemetry_Proto_Metrics_V1_DoubleHistogram {
    get {
      if case .doubleHistogram(let v)? = _storage._data {return v}
      return Opentelemetry_Proto_Metrics_V1_DoubleHistogram()
    }
    set {_uniqueStorage()._data = .doubleHistogram(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Data determines the aggregation type (if any) of the metric, what is the
  /// reported value type for the data points, as well as the relatationship to
  /// the time interval over which they are reported.
  ///
  /// TODO: Update table after the decision on:
  /// https://github.com/open-telemetry/opentelemetry-specification/issues/731.
  /// By default, metrics recording using the OpenTelemetry API are exported as
  /// (the table does not include MeasurementValueType to avoid extra rows):
  ///
  ///   Instrument         Type
  ///   ----------------------------------------------
  ///   Counter            Sum(aggregation_temporality=delta;is_monotonic=true)
  ///   UpDownCounter      Sum(aggregation_temporality=delta;is_monotonic=false)
  ///   ValueRecorder      TBD
  ///   SumObserver        Sum(aggregation_temporality=cumulative;is_monotonic=true)
  ///   UpDownSumObserver  Sum(aggregation_temporality=cumulative;is_monotonic=false)
  ///   ValueObserver      Gauge()
  public enum OneOf_Data: Equatable {
    case intGauge(Opentelemetry_Proto_Metrics_V1_IntGauge)
    case doubleGauge(Opentelemetry_Proto_Metrics_V1_DoubleGauge)
    case intSum(Opentelemetry_Proto_Metrics_V1_IntSum)
    case doubleSum(Opentelemetry_Proto_Metrics_V1_DoubleSum)
    case intHistogram(Opentelemetry_Proto_Metrics_V1_IntHistogram)
    case doubleHistogram(Opentelemetry_Proto_Metrics_V1_DoubleHistogram)

  #if !swift(>=4.1)
    public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data, rhs: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data) -> Bool {
      switch (lhs, rhs) {
      case (.intGauge(let l), .intGauge(let r)): return l == r
      case (.doubleGauge(let l), .doubleGauge(let r)): return l == r
      case (.intSum(let l), .intSum(let r)): return l == r
      case (.doubleSum(let l), .doubleSum(let r)): return l == r
      case (.intHistogram(let l), .intHistogram(let r)): return l == r
      case (.doubleHistogram(let l), .doubleHistogram(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Gauge represents the type of a int scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
/// 
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
public struct Opentelemetry_Proto_Metrics_V1_IntGauge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gauge represents the type of a double scalar metric that always exports the
/// "current value" for every data point. It should be used for an "unknown"
/// aggregation.
/// 
/// A Gauge does not support different aggregation temporalities. Given the
/// aggregation is unknown, points cannot be combined using the same
/// aggregation, regardless of aggregation temporalities. Therefore,
/// AggregationTemporality is not included. Consequently, this also means
/// "StartTimeUnixNano" is ignored for all data points.
public struct Opentelemetry_Proto_Metrics_V1_DoubleGauge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sum represents the type of a numeric int scalar metric that is calculated as
/// a sum of all reported measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_IntSum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  /// If "true" means that the sum is monotonic.
  public var isMonotonic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sum represents the type of a numeric double scalar metric that is calculated
/// as a sum of all reported measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_DoubleSum {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  /// If "true" means that the sum is monotonic.
  public var isMonotonic: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the type of a metric that is calculated by aggregating as a
/// Histogram of all reported int measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_IntHistogram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the type of a metric that is calculated by aggregating as a
/// Histogram of all reported double measurements over a time interval.
public struct Opentelemetry_Proto_Metrics_V1_DoubleHistogram {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint] = []

  /// aggregation_temporality describes if the aggregator reports delta changes
  /// since last report time, or cumulative changes since a fixed start time.
  public var aggregationTemporality: Opentelemetry_Proto_Metrics_V1_AggregationTemporality = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IntDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a int64 metric.
public struct Opentelemetry_Proto_Metrics_V1_IntDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Int64 = 0

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_IntExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DoubleDataPoint is a single data point in a timeseries that describes the
/// time-varying value of a double metric.
public struct Opentelemetry_Proto_Metrics_V1_DoubleDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Double = 0

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_DoubleExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IntHistogramDataPoint is a single data point in a timeseries that describes
/// the time-varying values of a Histogram of int values. A Histogram contains
/// summary statistics for a population of values, it may optionally contain
/// the distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This
  /// value must be equal to the sum of the "count" fields in buckets if a
  /// histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero. This value must be equal to the sum of the "sum" fields in
  /// buckets if a histogram is provided.
  public var sum: Int64 = 0

  /// bucket_counts is an optional field contains the count values of histogram
  /// for each bucket.
  ///
  /// The sum of the bucket_counts must equal the value in the count field.
  ///
  /// The number of elements in bucket_counts array must be by one greater than
  /// the number of elements in explicit_bounds array.
  public var bucketCounts: [UInt64] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  /// The bucket boundaries are described by "bounds" field.
  ///
  /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  /// at index i are:
  ///
  /// (-infinity, bounds[i]) for i == 0
  /// [bounds[i-1], bounds[i]) for 0 < i < N-1
  /// [bounds[i], +infinity) for i == N-1
  /// The values in bounds array must be strictly increasing.
  ///
  /// Note: only [a, b) intervals are currently supported for each bucket except the first one.
  /// If we decide to also support (a, b] intervals we should add support for these by defining
  /// a boolean value which decides what type of intervals to use.
  public var explicitBounds: [Double] = []

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_IntExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HistogramDataPoint is a single data point in a timeseries that describes the
/// time-varying values of a Histogram of double values. A Histogram contains
/// summary statistics for a population of values, it may optionally contain the
/// distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the last time when the aggregation value was reset
  /// to "zero". For some metric types this is ignored, see data types for more
  /// details.
  ///
  /// The aggregation value is over the time interval (start_time_unix_nano,
  /// time_unix_nano].
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the
  /// timestamp may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this aggregation value was reported.
  /// 
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This
  /// value must be equal to the sum of the "count" fields in buckets if a
  /// histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero. This value must be equal to the sum of the "sum" fields in
  /// buckets if a histogram is provided.
  public var sum: Double = 0

  /// bucket_counts is an optional field contains the count values of histogram
  /// for each bucket.
  ///
  /// The sum of the bucket_counts must equal the value in the count field.
  ///
  /// The number of elements in bucket_counts array must be by one greater than
  /// the number of elements in explicit_bounds array.
  public var bucketCounts: [UInt64] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  /// The bucket boundaries are described by "bounds" field.
  ///
  /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  /// at index i are:
  ///
  /// (-infinity, bounds[i]) for i == 0
  /// [bounds[i-1], bounds[i]) for 0 < i < N-1
  /// [bounds[i], +infinity) for i == N-1
  /// The values in bounds array must be strictly increasing.
  ///
  /// Note: only [a, b) intervals are currently supported for each bucket except the first one.
  /// If we decide to also support (a, b] intervals we should add support for these by defining
  /// a boolean value which decides what type of intervals to use.
  public var explicitBounds: [Double] = []

  /// (Optional) List of exemplars collected from
  /// measurements that were used to form the data point
  public var exemplars: [Opentelemetry_Proto_Metrics_V1_DoubleExemplar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A representation of an exemplar, which is a sample input int measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
public struct Opentelemetry_Proto_Metrics_V1_IntExemplar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that were filtered out by the aggregator, but recorded
  /// alongside the original measurement. Only labels that were filtered out
  /// by the aggregator should be included
  public var filteredLabels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// time_unix_nano is the exact time when this exemplar was recorded
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// Numerical int value of the measurement that was recorded.
  public var value: Int64 = 0

  /// (Optional) Span ID of the exemplar trace.
  /// span_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var spanID: Data = SwiftProtobuf.Internal.emptyData

  /// (Optional) Trace ID of the exemplar trace.
  /// trace_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var traceID: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A representation of an exemplar, which is a sample input double measurement.
/// Exemplars also hold information about the environment when the measurement
/// was recorded, for example the span and trace ID of the active span when the
/// exemplar was recorded.
public struct Opentelemetry_Proto_Metrics_V1_DoubleExemplar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that were filtered out by the aggregator, but recorded
  /// alongside the original measurement. Only labels that were filtered out
  /// by the aggregator should be included
  public var filteredLabels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// time_unix_nano is the exact time when this exemplar was recorded
  ///
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
  /// 1970.
  public var timeUnixNano: UInt64 = 0

  /// Numerical double value of the measurement that was recorded.
  public var value: Double = 0

  /// (Optional) Span ID of the exemplar trace.
  /// span_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var spanID: Data = SwiftProtobuf.Internal.emptyData

  /// (Optional) Trace ID of the exemplar trace.
  /// trace_id may be missing if the measurement is not recorded inside a trace
  /// or if the trace is not sampled.
  public var traceID: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.metrics.v1"

extension Opentelemetry_Proto_Metrics_V1_AggregationTemporality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AGGREGATION_TEMPORALITY_UNSPECIFIED"),
    1: .same(proto: "AGGREGATION_TEMPORALITY_DELTA"),
    2: .same(proto: "AGGREGATION_TEMPORALITY_CUMULATIVE"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_ResourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "instrumentation_library_metrics"),
  ]

  fileprivate class _StorageClass {
    var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
    var _instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _resource = source._resource
      _instrumentationLibraryMetrics = source._instrumentationLibraryMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._resource)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._instrumentationLibraryMetrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._instrumentationLibraryMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._instrumentationLibraryMetrics, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._instrumentationLibraryMetrics != rhs_storage._instrumentationLibraryMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentationLibraryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrumentation_library"),
    2: .same(proto: "metrics"),
  ]

  fileprivate class _StorageClass {
    var _instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary? = nil
    var _metrics: [Opentelemetry_Proto_Metrics_V1_Metric] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _instrumentationLibrary = source._instrumentationLibrary
      _metrics = source._metrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._instrumentationLibrary)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._metrics)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._instrumentationLibrary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._metrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._metrics, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics, rhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._instrumentationLibrary != rhs_storage._instrumentationLibrary {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "unit"),
    4: .standard(proto: "int_gauge"),
    5: .standard(proto: "double_gauge"),
    6: .standard(proto: "int_sum"),
    7: .standard(proto: "double_sum"),
    8: .standard(proto: "int_histogram"),
    9: .standard(proto: "double_histogram"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _unit: String = String()
    var _data: Opentelemetry_Proto_Metrics_V1_Metric.OneOf_Data?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _unit = source._unit
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._description_p)
        case 3: try decoder.decodeSingularStringField(value: &_storage._unit)
        case 4:
          var v: Opentelemetry_Proto_Metrics_V1_IntGauge?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .intGauge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .intGauge(v)}
        case 5:
          var v: Opentelemetry_Proto_Metrics_V1_DoubleGauge?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .doubleGauge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .doubleGauge(v)}
        case 6:
          var v: Opentelemetry_Proto_Metrics_V1_IntSum?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .intSum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .intSum(v)}
        case 7:
          var v: Opentelemetry_Proto_Metrics_V1_DoubleSum?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .doubleSum(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .doubleSum(v)}
        case 8:
          var v: Opentelemetry_Proto_Metrics_V1_IntHistogram?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .intHistogram(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .intHistogram(v)}
        case 9:
          var v: Opentelemetry_Proto_Metrics_V1_DoubleHistogram?
          if let current = _storage._data {
            try decoder.handleConflictingOneOf()
            if case .doubleHistogram(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._data = .doubleHistogram(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._unit.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unit, fieldNumber: 3)
      }
      switch _storage._data {
      case .intGauge(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .doubleGauge(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .intSum(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .doubleSum(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .intHistogram(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .doubleHistogram(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric, rhs: Opentelemetry_Proto_Metrics_V1_Metric) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._unit != rhs_storage._unit {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntGauge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntGauge, rhs: Opentelemetry_Proto_Metrics_V1_IntGauge) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleGauge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleGauge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleGauge, rhs: Opentelemetry_Proto_Metrics_V1_DoubleGauge) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntSum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
    3: .standard(proto: "is_monotonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      case 2: try decoder.decodeSingularEnumField(value: &self.aggregationTemporality)
      case 3: try decoder.decodeSingularBoolField(value: &self.isMonotonic)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    if self.isMonotonic != false {
      try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntSum, rhs: Opentelemetry_Proto_Metrics_V1_IntSum) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.isMonotonic != rhs.isMonotonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleSum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
    3: .standard(proto: "is_monotonic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      case 2: try decoder.decodeSingularEnumField(value: &self.aggregationTemporality)
      case 3: try decoder.decodeSingularBoolField(value: &self.isMonotonic)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    if self.isMonotonic != false {
      try visitor.visitSingularBoolField(value: self.isMonotonic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleSum, rhs: Opentelemetry_Proto_Metrics_V1_DoubleSum) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.isMonotonic != rhs.isMonotonic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntHistogram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      case 2: try decoder.decodeSingularEnumField(value: &self.aggregationTemporality)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntHistogram, rhs: Opentelemetry_Proto_Metrics_V1_IntHistogram) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleHistogram: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleHistogram"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_points"),
    2: .standard(proto: "aggregation_temporality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dataPoints)
      case 2: try decoder.decodeSingularEnumField(value: &self.aggregationTemporality)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataPoints, fieldNumber: 1)
    }
    if self.aggregationTemporality != .unspecified {
      try visitor.visitSingularEnumField(value: self.aggregationTemporality, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogram, rhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogram) -> Bool {
    if lhs.dataPoints != rhs.dataPoints {return false}
    if lhs.aggregationTemporality != rhs.aggregationTemporality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
    5: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularSFixed64Field(value: &self.value)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.exemplars)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularSFixed64Field(value: self.value, fieldNumber: 4)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_IntDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
    5: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularDoubleField(value: &self.value)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.exemplars)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 4)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntHistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "bucket_counts"),
    7: .standard(proto: "explicit_bounds"),
    8: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularFixed64Field(value: &self.count)
      case 5: try decoder.decodeSingularSFixed64Field(value: &self.sum)
      case 6: try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts)
      case 7: try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.exemplars)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularSFixed64Field(value: self.sum, fieldNumber: 5)
    }
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_IntHistogramDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleHistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "bucket_counts"),
    7: .standard(proto: "explicit_bounds"),
    8: .same(proto: "exemplars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularFixed64Field(value: &self.count)
      case 5: try decoder.decodeSingularDoubleField(value: &self.sum)
      case 6: try decoder.decodeRepeatedFixed64Field(value: &self.bucketCounts)
      case 7: try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.exemplars)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularFixed64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.bucketCounts.isEmpty {
      try visitor.visitPackedFixed64Field(value: self.bucketCounts, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    if !self.exemplars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exemplars, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleHistogramDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.bucketCounts != rhs.bucketCounts {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.exemplars != rhs.exemplars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_IntExemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntExemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filtered_labels"),
    2: .standard(proto: "time_unix_nano"),
    3: .same(proto: "value"),
    4: .standard(proto: "span_id"),
    5: .standard(proto: "trace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.filteredLabels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 3: try decoder.decodeSingularSFixed64Field(value: &self.value)
      case 4: try decoder.decodeSingularBytesField(value: &self.spanID)
      case 5: try decoder.decodeSingularBytesField(value: &self.traceID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filteredLabels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filteredLabels, fieldNumber: 1)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularSFixed64Field(value: self.value, fieldNumber: 3)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_IntExemplar, rhs: Opentelemetry_Proto_Metrics_V1_IntExemplar) -> Bool {
    if lhs.filteredLabels != rhs.filteredLabels {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleExemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleExemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filtered_labels"),
    2: .standard(proto: "time_unix_nano"),
    3: .same(proto: "value"),
    4: .standard(proto: "span_id"),
    5: .standard(proto: "trace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.filteredLabels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 3: try decoder.decodeSingularDoubleField(value: &self.value)
      case 4: try decoder.decodeSingularBytesField(value: &self.spanID)
      case 5: try decoder.decodeSingularBytesField(value: &self.traceID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filteredLabels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filteredLabels, fieldNumber: 1)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 3)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 4)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleExemplar, rhs: Opentelemetry_Proto_Metrics_V1_DoubleExemplar) -> Bool {
    if lhs.filteredLabels != rhs.filteredLabels {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
